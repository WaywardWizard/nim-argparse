import std/[strformat,strutils,sequtils,options,sets,algorithm]
import ../types

const COMPLETION_HEADER_FISH* =  "# Autogenerated fish shell completions \n"

# The command name is determined at runtime (based on binary name) so is
# templated as {prog} for replacing at runtime.
template startCompleteCommand():untyped =
  result = "complete -c {prog} " # {prog} to be replaced at runtime
  
template addFlag(short:string,long:string,require:bool=true):untyped =
  if require and short=="" and long=="":
    raise ValueError.newException("At least one of short or long flag must be provided for flag completion")
  if short != "": result &= "-s " & short[1..^1] & " "
  if long != "": result &= "-l " & long[2..^1] & " "
    
template addHelp():untyped =
  if help != "": result &= "-d '$#' " % [help.replace("'", "\\'")]
    
template addCompletions(): untyped =
  if completionsGenerator == "" and completionsList.len == 0:
    discard
  else:
    let completionsStr = completionsList.join(" ")
    
    result &= "-a \""
    if completionsStr != "":
      result &= completionsStr & " "
    if completionsGenerator != "":
      result &= "(" & completionsGenerator & ")"
    result &= "\" "
    
template scopeSubcommand(): untyped =
  if subcommandPath.len > 0:
    result &= "-n '"
    result &= &"__fish_seen_subcommand_from {subcommandPath[0]}"
    for subc {.inject.} in subcommandPath[1..^1]:
      result &= &";and __fish_seen_subcommand_from {subc}"
    for subc {.inject.} in untraversedSubcommands:
      result &= &";and not __fish_seen_subcommand_from {subc}"
    result &= "' "
    
proc getFishShellCompletion(
  subcommands: openArray[string],
  help: string = "",
  subcommandPath: openArray[string] = @[],
  untraversedSubcommands: openArray[string] = @[],
  noFiles=true,
): string {.compiletime.} = 
  ## Adds subcommands
  template addSubcommands(): untyped =
    if subcommands.len > 0:
      if subcommandPath.len == 0:
        result &= "-n '__fish_use_subcommand' "
      result &= "-a '" & subcommands.join(" ") & "' "
  
  startCompleteCommand()
  addhelp() 
  scopeSubcommand()
  if noFiles: result &= "-f " # no file completions, option to come
  addSubcommands()

proc getFishShellCompletion(
  component: Component,
  untraversedSubcommands: openArray[string] = @[], # block these completions
  subcommandPath: openArray[string] = @[], # for subcommands, the path to this command
  noFiles=true, 
):string {.compiletime.} =
  ## Adds arguments
  startCompleteCommand()
  let help = component.help;addhelp() 
  scopeSubcommand()
  case component.kind
  of ArgOption: # require option string, add completions for it
    let
      completionsList = component.optChoices
      completionsGenerator = component.optCompletionsGenerator[sckFish]
    result &= "-r " # a flag requires argument if the flag given
    if noFiles: result &= "-f "
    addFlag(component.optShort,component.optLong) #  ArgFlag/ArgOption
    addCompletions()
  of ArgFlag:
    addFlag(component.flagShort,component.flagLong)
  of ArgArgument:
    let completionsList: seq[string]= @[]
    let completionsGenerator = component.argCompletionsGenerator[sckFish]
    addCompletions()
  
# Importing backend will create a circular dep
proc allChildren*(builder: Builder): seq[Builder] =
  ## Return all the descendents of this builder
  for child in builder.children:
    result.add child
    result.add child.allChildren()

proc getFishShellCompletionsTemplate*(
  b:Builder,
  allSubcommandsPre:Option[HashSet[string]]=none[HashSet[string]]()
): seq[string] {.compiletime.} =
  ## Get the completion definitions for the target shell
  ## 
  ## allSubcommands can be passed in to avoid recomputing it for subcommands
  ## 
  ## Return a list of completion commands for fish shell sans the command itself
  result = newSeq[string]()
  result.add COMPLETION_HEADER_FISH
  
  var subcommandPath: seq[string] = @[]
  var bCursor = some(b)
  while bCursor.get().parent.isSome:
    subcommandPath.add bCursor.get().name
    bCursor = bCursor.get().parent
  subcommandPath.reverse() # top down
  
  # bCursor is top-level
  let allSubcommands = 
    if allSubcommandsPre.isNone():
      some(bCursor.get().allChildren().mapIt(it.name).toHashSet())
    else:
      allSubcommandsPre
    
  let untraversedSubcommands = (allSubcommands.get() - subcommandPath.toHashSet).toSeq
  # argument completions
  for c in b.components:
    result.add getFishShellCompletion(
      component = c,
      subcommandPath = subcommandPath,
      untraversedSubcommands = untraversedSubcommands,
    )   
  # subcommand completions
  for child in b.children:
    result.add getFishShellCompletion(
      subcommands = [child.name],
      help = child.help,
      subcommandPath = subcommandPath,
      untraversedSubcommands = untraversedSubcommands,
    )
  # underneath subcommand argument completions
  for child in b.children:
    result.add child.getFishShellCompletionsTemplate(allSubcommandsPre)