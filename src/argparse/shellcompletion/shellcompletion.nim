## # Architecture
## ## Compiletime
## - Code generation hooks added to `argparse/backend`_
##   - AST specific to the ArgOption for shell completion added to `parseProcDef`_
##     - Process env SHELL to derive target shell
##     - Hotwire to trigger short circuiting for shell completion generation
## - Implementation for completion printing, `shellcompletion.nim`_, `fish.nim`_
##   - Macros producing AST to;
##     - Generate completions for each supported shell given a Builder instance
##     - Raise a completions short circuit
##     - Implement the short circuit behaviour
##
## ### Further Detail
## - parse, generated by `parseProcDef`_, will;
##    - derive the target shell from the SHELL env or command line argument
##    - a hotwire NimNode will be injected after the body of the case statement
##      that handles ArgOption tokens.
##    - The hotwire will short circuit for the shell completion generation arg
##    - When run() was called, the short circuits associated behaviour will run
##    - When parse() was called, the short circuit will be raised
##    - Short circuit behaviour is defined by `shortCircuitBehaviourProcDef`_
## - completion generation occurs at compiletime and persists to runtime
##   - Each builder has a const containing the various shell completion.
##   - get<shell>ShellCompletionsTemplate(b:Builder) procs return seq[string] AST
##   - AST defining a const containing generated shell completion strings is
##     produced by `getCompletionsConstDef`_
##   - At runtime the completion opt is given and the relevant shell completion
##     is looked up from the const and printed
##
## # Adding shells to completion generation
## - Implementation is shell specific located in <shell>.nim
##   - Provide a `proc get<shellName>ShellCompletionsTemplate` that should
##     return a seq[string], elements of which are shell commands that will declare
##     completions. Each string will have any (exact) occurences of `{prog}`
##     replaced at runtime with the actual binary name. This proc should take
##     a builder instance as an argument.
## - The only modification to make in `shellcompletion.nim`_ is to add the shell
##   to the `ShellCompletionKind` enum.
##
## # Shell Completion Option
##
## - `Component`_ may have a shell command that generates completions for itself
## - This is specified as an argument to `argparse.nim`_ `opt()`_ and `arg()`_
##   - `opt`_ now has the optional field `optCompletionsGenerator`
##   - `arg`_ now has the optional field `argCompletionsGenerator`
##   - Examples for fish
##     - __fish_complete_directories
##     - __fish_complete_pids
##
## # Notes
## Fish completions are declarative, but other shells are procedural,
## consequentially its not easy to abstract completion generation to a unified
## interface thus each shell should have its own module for handling its own
## specifics
##
## # Deadends
## The challenge is accessing data computed at compiletime at runtime based on
## runtime values. Assigning completions for a shell to a const wont work because
## it will be necessary to derive the name of that const at runtime based on The
## chosen shell.

import std/[sequtils, macros, strutils, options]
import ../types, fish
import ../util
import ../util

const COMPLETION_OPT_VARNAME* = "argparse_completion_definitions"
const COMPLETION_SHELLS* = toSeq(ShellCompletionKind).mapIt($it)
const COMPLETION_LONG_FLAG = "completionDefinitions"
const COMPLETION_DEFINITIONS_CONST_NAME = "COMPLETION_DEFINITIONS"
const COMPLETION_OPT* = Component(
  varname: COMPLETION_OPT_VARNAME,
  help: "Print shell completion definitions for shell if given, else $SHELL",
  kind: ArgOption,
  env: "SHELL",
  optLong: "--" & COMPLETION_LONG_FLAG,
  optChoices: COMPLETION_SHELLS,
  optRequired: false,
)

proc deriveShellFromEnvVar*(envVar: string): string =
  envVar.split("/")[^1]

# Here we are producing AST to call the relevant completion generation proc
# A builder argument is required. quote do gives us indirection to call the
# proc. b is a nimvm varible, in scope at compiletime. AST is for runtime.
# This AST is to be injected into the const definition block below which will
# be a static context and executed at compiletime due to constant folding.
# Thus, this ASTs runtime will be the nimvm.
#
# to generato completions we need access to the builder. thus we should call
# getCompletions at compiletime. The completions will then be accessed at
# runtime. This requires persisting a value from compiletime to runtime. A
# const is the tool for this. AST (for runtime) should be generated defining
# a const. Thus the getCompletions proc should return AST, be callable at
# compiletime and return a nimnode (ast) representing a seq[string].
#
# The strategy is then
# - At compiletime, call get<shell>ShellCompletionsTemplate(b:Builder)
# - Make AST to assign returned AST to a const array[ShellCompletionKind]
# - Run AST at runtime after a user passed a completions option

# proc nameOfCompletionsConst(b:Builder,s:ShellCompletionKind):string {.compiletime.} =
#   b.symbol & "_" & $s & "_SHELL_COMPLETIONS"
proc getCompletionDefinitionsConstDef(b: Builder): NimNode {.compiletime.} =
  ## Produce const definition for shell completion definitions. This should be
  ## called in non global scope that is specific to the builder/parser which it
  ## belongs to.
  if b.parent.isSome():
    raise newException(
      ValueError, "getCompletionsConstDef can only be called on top-level Builders"
    )

  # array[ShellCompletionKind,string]
  let constType =
    nnkBracketExpr.newTree(ident"array", ident"ShellCompletionKind", ident"string")

  # Build array literal: [sckFish: "completions...", ...]
  var arrayElements = nnkBracket.newTree()
  for shell in ShellCompletionKind.low .. ShellCompletionKind.high:
    let completions: seq[string] = block:
      case shell
      of sckFish:
        getFishShellCompletionsTemplate(b)
    arrayElements.add newLit(completions.join("\n"))

  # const COMPLETION_DEFINITIONS: array[ShellCompletionKind, string] = [...]
  nnkConstSection.newTree(
    nnkConstDef.newTree(
      ident(COMPLETION_DEFINITIONS_CONST_NAME), constType, arrayElements
    )
  )

proc getCompletionDefinitionsProcDef(b: Builder): NimNode {.compiletime.} =
  ## Produce proc to return completion statements for target shell argument
  ## for given builder (there may be more than one builder in a program)
  ##
  ## proc getCompletionDefinitions() will use the const `getCompletionsConstIdent`_
  ##
  ## #Notes
  ## Result to ultimately be executed by the target shell
  newProc(
    name = ident"getCompletionDefinitions",
    params = [
      ident"string",
      newIdentDefs(ident"parser", b.parserIdent()),
      newIdentDefs(ident"shell", ident"ShellCompletionKind"),
    ],
    procType = nnkProcDef,
    body = nnkStmtList.newTree(
      newLetStmt(ident"progname", b.getProgNameAst()),
      # return COMPLETION_DEFINITIONS_CONST_NAME[shell].replace("{prog}", progname)
      nnkReturnStmt.newTree(
        nnkCall.newTree(
          nnkDotExpr.newTree(
            nnkBracketExpr.newTree(
              ident(COMPLETION_DEFINITIONS_CONST_NAME), ident"shell"
            ),
            ident"replace",
          ),
          newLit"{prog}",
          ident"progname",
        )
      ),
    ),
  )

proc getShortCircuitBehaviourImpl*(b: Builder): NimNode =
  ## Called at runtime to yield AST of a proc body which implements ShortCircuit
  ## behaviour for shell completion generation. Called inside the scope of
  ## parse(), generated by `parseProcDef`_ and in a closure over `opts`,
  ## `parser`, and `output`. The AST of `getCompletionDefinitionsProcDef`_ shall
  ## have been injected and in scope before this AST is executed.
  result = newStmtList()
  result.add b.getCompletionDefinitionsConstDef()
  result.add b.getCompletionDefinitionsProcDef()
  let fieldAccess = newDotExpr(ident"opts", ident(COMPLETION_OPT_VARNAME))
  result.add quote do:
    let shellStr = `fieldAccess`
    let shell = parseEnum[ShellCompletionKind](shellStr)
    output.writeLine(parser.getCompletionDefinitions(shell))
