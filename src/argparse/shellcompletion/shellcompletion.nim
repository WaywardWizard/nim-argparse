## # Architecture
## ## Compiletime
## - Code generation hooks added to `argparse/backend`_
##   - AST specific to the ArgOption for shell completion added to `parseProcDef`_
##     - Process env SHELL to derive target shell
##     - Hotwire to trigger short circuiting for shell completion generation
## - Implementation for completion printing, `shellcompletion.nim`_, `fish.nim`_
##   - Macros producing AST to;
##     - Generate completions for each supported shell given a Builder instance
##     - Raise a completions short circuit
##     - Implement the short circuit behaviour
## 
## ### Further Detail
## - parse, generated by `parseProcDef`_, will;
##    - derive the target shell from the SHELL env or command line argument
##    - a hotwire NimNode will be injected after the body of the case statement
##      that handles ArgOption tokens.
##    - The hotwire will short circuit for the shell completion generation arg
##    - When run() was called, the short circuits associated behaviour will run
##    - When parse() was called, the short circuit will be raised
##    - Short circuit behaviour is defined by `shortCircuitBehaviourProcDef`_
## - completion generation occurs at compiletime and persists to runtime
##   - Each builder has a const containing the various shell completion.
##   - get<shell>ShellCompletionsTemplate(b:Builder) procs return seq[string] AST
##   - AST defining a const containing generated shell completion strings is 
##     produced by `shellCompletionsConstDef`_
##   - At runtime the completion opt is given and the relevant shell completion
##     is looked up from the const and printed
## 
## # Adding shells to completion generation
## - Implementation is shell specific located in <shell>.nim
##   - Provide a `proc get<shellName>ShellCompletionsTemplate` that should 
##     return a seq[string], elements of which are shell commands that will declare 
##     completions. Each string will have any (exact) occurences of `{prog}` 
##     replaced at runtime with the actual binary name. This proc should take
##     a builder instance as an argument.
## - The only modification to make in `shellcompletion.nim`_ is to add the shell
##   to the `ShellCompletionKind` enum.
## 
## # Shell Completion Option
##  
## - `Component`_ may have a shell command that generates completions for itself
## - This is specified as an argument to `argparse.nim`_ `opt()`_ and `arg()`_
##   - `opt`_ now has the optional field `optCompletionsGenerator`
##   - `arg`_ now has the optional field `argCompletionsGenerator`
##   - Examples for fish
##     - __fish_complete_directories
##     - __fish_complete_pids
## 
## # Notes
## Fish completions are declarative, but other shells are procedural, 
## consequentially its not easy to abstract completion generation to a unified
## interface thus each shell should have its own module for handling its own 
## specifics

import std/[sequtils,macros,strformat,strutils,options]
import ../types, fish

const COMPLETION_OPT_VARNAME* = "argparse_completion_definitions"
const COMPLETION_SHELLS* = toSeq(ShellCompletionKind).mapIt($it)


# const COMPLETION_OPT* = Component(
#   varname: COMPLETION_OPT_VARNAME,
#   help: "Print shell completion definitions for shell if given, else $SHELL",
#   kind: ArgOption,
#   env: "SHELL",
#   optLong: "--completionDefinitions",
#   optChoices: COMPLETION_SHELLS,
#   optRequired: false
# )
  
proc deriveShellFromEnvVar*(envVar:string):string = envVar.split("/")[^1]
  
# Here we are producing AST to call the relevant completion generation proc
# A builder argument is required. quote do gives us indirection to call the
# proc. b is a nimvm varible, in scope at compiletime. AST is for runtime.
# This AST is to be injected into the const definition block below which will
# be a static context and executed at compiletime due to constant folding.
# Thus, this ASTs runtime will be the nimvm.
# 
# to generato completions we need access to the builder. thus we should call
# getCompletions at compiletime. The completions will then be accessed at 
# runtime. This requires persisting a value from compiletime to runtime. A
# const is the tool for this. AST (for runtime) should be generated defining
# a const. Thus the getCompletions proc should return AST, be callable at 
# compiletime and return a nimnode (ast) representing a seq[string].
# 
# The strategy is then
# - At compiletime, call get<shell>ShellCompletionsTemplate(b:Builder)
# - Make AST to assign returned AST to a const array[ShellCompletionKind]
# - Run AST at runtime after a user passed a completions option
    
# shellCompletionsConst(.*) injected by `generateDefs`_ and the const used by
# proc getCompletionDefinitions defined in `getCompletionDefinitionsProcDef`_
proc shellCompletionsConstIdent(b:Builder): NimNode {.compiletime.} =
  ident(b.symbol&"_SHELL_COMPLETIONS")
proc shellCompletionsConstDef*(b:Builder): NimNode {.compiletime.} =
  ## Produce const definition for shell completion definitions
  if b.parent.isSome():
    raise newException(
      ValueError,
      "shellCompletionsConstDef can only be called on top-level Builders"
    )
  let constIdent = b.shellCompletionsConstIdent()
  let sck = bindSym"ShellCompletionKind" # bind here avoid caller scope assumptn
  let stpl = nnkBracketExpr.newTree(ident"array",sck,ident"string")
  let unrolledShellCompletionAssigns = newStmtList()
  
  for shell in ShellCompletionKind.low .. ShellCompletionKind.high:
    let completions: seq[string] = block:
      case shell
      of sckFish:
        getFishShellCompletionsTemplate(b)
    # this is going to be executed at compiletime due to constant folding
    unrolledShellCompletionAssigns.add(
      newAssignment(
        nnkBracketExpr.newTree(
          ident"tmp",
          newLit(shell)
        ),
        newLit(completions)
      )
    )
    
  result = nnkConstDef.newTree(constIdent,
    stpl,
    newBlockStmt(newStmtList(
      newVarStmt(
        ident"tmp",
        newCall(nnkBracketExpr.newTree(ident"default",stpl),stpl)
      ),
      unrolledShellCompletionAssigns,
      ident"tmp"
    ))
  )
  echo result.repr
      
proc getCompletionDefinitionsProcDef(b:Builder): NimNode {.compiletime.} =
  ## Produce proc to return completion statements for target shell argument
  ## for given builder (there may be more than one builder in a program)
  ## 
  ## proc getCompletionDefinitions() will use the const `shellCompletionsConstIdent`_
  ## 
  ## #Notes
  ## Result to ultimately be executed by the target shell
  var completionTemplatesConstIdent = b.shellCompletionsConstIdent()
  quote do:
    proc getCompletionDefinitions(
      parser: `b.parserIdent()`,
      shell: ShellCompletionKind
    ): seq[string] =
      let progname = getProgName()
      return `completionTemplatesConstIdent`[shell].mapIt(it.replace("{prog}", progname))

proc getShortCircuitBehaviour(b:Builder): NimNode = 
  ## Called at runtime to yield AST of a proc body which implements ShortCircuit 
  ## behaviour for shell completion generation. Called inside the scope of
  ## parse(), generated by `parseProcDef`_ and in a closure over `opts`,
  ## `parser`, and `output`. The AST of `getCompletionDefinitionsProcDef`_ shall
  ## have been injected and in scope before this AST is executed.
  result = newStmtList()
  result.add b.getCompletionDefinitionsProcDef()
  result.add quote do:
    let shell = opts.`COMPLETION_OPT_VARNAME`
    output.writeLines(parser.getCompletionDefinitions(shell))
    quit(0)
    
# Builder is a compile time variable which exists in the scope of `domkParser`_
# and is required to link the builder specific generated completion definitions 
# so that the short circuit behaviour may print them
proc raiseShortCircuitForCompletionDefinitions*(b:Builder):NimNode =
  ## Raise ShortCircuit exception for shell completion definitions
  let behaviour = b.getShortCircuitBehaviour()
  quote do:
    raise newException(
      ShortCircuit,
      "Generating shell completion definitions",
      proc() = 
        `behaviour`
    )
