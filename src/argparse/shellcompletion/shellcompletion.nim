## # Architecture
## ## Compiletime
## - Hooks added to `argparse/backend`_ 
##   - hotwire, triggers short circuit on completion option
##   - shortcircuit, triggered by standart mechanism on completion flag
## - Handler for shortcircuit generated by `getShortCircuitBehaviourImpl`_
##   - Process env SHELL to derive target shell
##   - Print completions
## - Implementation for completion printing, `shellcompletion.nim`_, `fish.nim`_
## 
## ### Further Detail
## - completion generation occurs at compiletime and persists to runtime
## - const array indexed by `ShellCompletionKind` containing completions
## - lookup at runtime based on user input
#
## # Notes
## Fish completions are declarative, but other shells are procedural,
## consequentially its not easy to abstract completion generation to a unified
## interface thus each shell should have its own module for handling its own
## specifics
import std/[sequtils, macros, strutils, options]
# We will not import backend here to avoid circular dependencies
import ../types, fish
import ../util

const COMPLETION_OPT_VARNAME* = "shell"
const COMPLETION_FLAG_VARNAME* = "printCompletions"
const COMPLETION_SHELLS* = toSeq(ShellCompletionKind).mapIt($it)
const COMPLETION_LONG_FLAG* = "completionDefinitions"
const COMPLETION_LONG_HELP* =
  "Print shell completion definitions for given shell" 
const COMPLETION_SHORT_FLAG* = "c"
const COMPLETION_SHORT_HELP* = "Print shell completion definitions for env $SHELL"
const COMPLETION_DEFINITIONS_CONST_NAME = "COMPLETION_DEFINITIONS"
const COMPLETION_HEADER* = "# Autogenerated shell completions \n"
const COMPLETION_OPT* = Component(
  varname: COMPLETION_OPT_VARNAME,
  help: COMPLETION_LONG_HELP,
  kind: ArgOption,
  env: "SHELL",
  optLong: "--" & COMPLETION_LONG_FLAG,
  optChoices: COMPLETION_SHELLS,
  optRequired: false,
)
const COMPLETION_FLAG* = Component(
  varname: COMPLETION_FLAG_VARNAME,
  help: COMPLETION_SHORT_HELP,
  kind: ArgFlag,
  flagShort: "-" & COMPLETION_SHORT_FLAG,
  shortCircuit: true,
)

proc deriveShellFromEnvVar*(envVar: string): string =
  envVar.split("/")[^1]

proc getCompletionDefinitionsConstDef(b: Builder): NimNode {.compiletime.} =
  ## Produce const definition for shell completion definitions. This should be
  ## called in non global scope that is specific to the builder/parser which it
  ## belongs to.
  if b.parent.isSome():
    raise newException(
      ValueError, "getCompletionsConstDef can only be called on top-level Builders"
    )

  # array[ShellCompletionKind,string]
  let constType =
    nnkBracketExpr.newTree(ident"array", ident"ShellCompletionKind", ident"string")

  # Build array literal: [sckFish: "completions...", ...]
  var arrayElements = nnkBracket.newTree()
  let header = COMPLETION_HEADER
  for shell in ShellCompletionKind.low .. ShellCompletionKind.high:
    let completions: seq[string] = block:
      case shell
      of sckFish:
        getFishShellCompletionsTemplate(b)
    arrayElements.add newLit(header & completions.join("\n"))

  # const COMPLETION_DEFINITIONS: array[ShellCompletionKind, string] = [...]
  nnkConstSection.newTree(
    nnkConstDef.newTree(
      ident(COMPLETION_DEFINITIONS_CONST_NAME), constType, arrayElements
    )
  )

proc getCompletionDefinitionsProcDef(b: Builder): NimNode {.compiletime.} =
  ## Produce proc to return completion statements for target shell argument
  ## for given builder (there may be more than one builder in a program)
  ##
  ## proc getCompletionDefinitions() will use the const `getCompletionsConstIdent`_
  ##
  ## #Notes
  ## Result to ultimately be executed by the target shell
  newProc(
    name = ident"getCompletionDefinitions",
    params = [
      ident"string",
      newIdentDefs(ident"parser", b.parserIdent()),
      newIdentDefs(ident"shell", ident"ShellCompletionKind"),
    ],
    procType = nnkProcDef,
    body = nnkStmtList.newTree(
      newLetStmt(ident"progname", b.getProgNameAst()),
      # return COMPLETION_DEFINITIONS_CONST_NAME[shell].replace("{prog}", progname)
      nnkReturnStmt.newTree(
        nnkCall.newTree(
          nnkDotExpr.newTree(
            nnkBracketExpr.newTree(
              ident(COMPLETION_DEFINITIONS_CONST_NAME), ident"shell"
            ),
            ident"replace",
          ),
          newLit"{prog}",
          ident"progname",
        )
      ),
    ),
  )

proc getShortCircuitBehaviourImpl*(b: Builder): NimNode =
  ## AST implementing behaviour to enact on a shortcircuit for completions
  ##
  ## Executed at runtime in the context of `parse`_ declared in `parseProcDef`_
  ##
  ## Called when user passed completions flag or option. Where they passed the
  ## flag pull the shell from env var SHELL. Where they passed the option
  ## use that. Where they passed the flag and the option use the option.

  ## `parser`, and `output`. The AST of `getCompletionDefinitionsProcDef`_ shall
  ## have been injected and in scope before this AST is executed.
  result = newStmtList()

  result.add b.getCompletionDefinitionsConstDef()
  result.add b.getCompletionDefinitionsProcDef()
  let optAccess = newDotExpr(ident"opts", ident(COMPLETION_OPT_VARNAME))
  result.add quote do:
    let shellStr:string =  when compiles(`optAccess`):
      # given the short flag this will be the SHELL env value, so derive shell
      deriveShellFromEnvVar(`optAccess`)
    else: 
      # opt disabled, short flag given
      deriveShellFromEnvVar(getEnv("SHELL"))
    let shell = try:
      parseEnum[ShellCompletionKind](shellStr)
    except CatchableError:
      raise UsageError.newException("Invalid shell for completions: " & shellStr)
      
    output.writeLine(parser.getCompletionDefinitions(shell))

